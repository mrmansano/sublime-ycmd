#!/usr/bin/env python3

'''
lib/task/worker.py
Task pool worker thread.

Runs a thread to process items in a task pool. The class itself does not
inherit from `threading.Thread` directly. Instead, a helper function is exposed
for use in a thread target.
'''

import queue
import logging
import threading

from lib.task.pool import Pool
from lib.task.task import Task

logger = logging.getLogger('sublime-ycmd.' + __name__)


def spawn_worker(pool, name=None):
    '''
    Generates a new `Worker` instance with a dedicated `threading.Thread`.
    The thread will run an infinite processing loop via the worker class on the
    given task `pool`.
    If `name` is provided, the thread is given the corresponding name. If
    omitted, a default will be generated by `threading.Thread`.

    Worker threads are always created with the `daemon` flag. This allows the
    process to exit when non-daemon threads exit. These worker threads are only
    meant to support the plugin, so it doesn't make sense to let them persist.
    '''
    if name is not None and not isinstance(name, str):
        raise TypeError('name must be a str: %r' % (name))

    worker_instance = Worker(pool)

    def run_worker():
        worker_instance.run()

    worker_thread = threading.Thread(target=run_worker, name=name)
    worker_instance.handle = worker_thread

    logger.debug('created worker: %r', worker_instance)

    worker_thread.start()
    return worker_instance


class Worker(object):
    '''
    Worker thread abstraction class.

    Defines a worker unit that runs an infinite loop, processing tasks from a
    task pool.

    This class is compatible with (i.e. can inherit from) `threading.Thread`.
    It is deliberately left as a plain object though.

    Most methods are thread-safe, but certain controller methods aren't.

    TODO : Use a log adapter to decorate based on worker info.
    '''

    def __init__(self, pool, handle=None):
        self._pool = None       # type: Pool
        self._handle = None     # type: threading.Thread
        self._lock = threading.Lock()

        self._running = False

        self.pool = pool
        self.handle = handle

    def run(self):
        '''
        Starts the worker thread, running an infinite loop waiting for jobs.

        This should be run on an alternate thread, as it will block.

        Thread-safe.
        '''
        with self._lock:
            if not self._pool:
                raise AttributeError('no task pool set')

        def _wait_condition():
            '''
            Helper function used with `threading.Condition.wait_for`.

            Defines the condition to wait for when running the infinite loop.
            This basically just waits until the `self._running` state changes,
            or when a message is received on the queue.

            NOTE : This is assumed to be executed with the pool lock held.
            '''
            with self._lock:
                if not self._running:
                    # need to break out of loop, so generate event data
                    return WorkerEvent(WorkerEvent.RUNSTATE, self._running)
                # else, fall through, and check if a task is available instead

            try:
                # don't block - raise exception if no task available
                task = self._pool.get(False)
            except queue.Empty:
                task = None

            if task is not None:
                # have a task! set up the event to process it
                return WorkerEvent(WorkerEvent.TASK, task)

            # explicitly return `False` to go back to waiting
            return False

        logger.debug('task worker about to start: %r', self)

        with self._lock:
            self._running = True

        while True:
            with self._pool.cv:
                worker_event = self._pool.cv.wait_for(_wait_condition)
            logger.debug('received worker event: %r', worker_event)

            if worker_event.is_run_state():
                # running state updated, if set to false, stop running (break)
                keep_running = worker_event.data
                if not keep_running:
                    logger.debug('received stop request, breaking out of loop')
                    break

            if worker_event.is_task():
                # task available, process it
                task = worker_event.data    # type: Task

                if task.is_cancelled():
                    logger.debug('skipping cancelled task: %r', task)
                    continue

                logger.debug('preparing to run task: %r', task)
                task()
                self._pool.task_done()
                logger.debug('finished running task: %r', task)

                # return to waiting state
                continue

            # unknown event type...
            raise ValueError('unknown worker event: %r' % (worker_event))

        logger.debug('task worker about to exit: %r', self)

    def stop(self):
        '''
        Shuts down the worker thread by breaking out of the infinite run loop.

        Thread-safe.
        '''
        with self._lock:
            if not self._pool:
                raise AttributeError('no task pool set')

            self._running = False

        with self._pool.cv:
            self._pool.cv.notify_all()

    def join(self, timeout=None):
        '''
        Joins the underlying thread for this worker.

        If `timeout` is omitted, this will block indefinitely until the thread
        has exited.
        If `timeout` is provided, it should be the maximum number of seconds to
        wait until returning. If the thread is still alive after the timeout
        expires, a `TimeoutError` will be raised.
        '''
        with self._lock:
            handle = self._handle
            if not handle:
                raise AttributeError('no thread handle set')

        handle.join(timeout=timeout)
        if handle.is_alive():
            timeout_desc = (
                ' after %rs' % (timeout) if timeout is not None else ''
            )
            raise TimeoutError('thread did not exit%s' % (timeout_desc))

    @property
    def pool(self):
        '''
        Retrieves the currently held task pool (reference), if any.

        NOT Thread-safe.
        '''
        return self._pool

    @pool.setter
    def pool(self, pool):
        '''
        Sets the task pool for the worker.

        Thread-safe, but shouldn't be used across threads.
        '''
        if not isinstance(pool, Pool):
            raise TypeError('pool must be a Pool: %r' % (pool))

        with self._lock:
            if self._pool is not None:
                logger.error(
                    'overwriting task pool, discarding: %r', self._pool,
                )

            self._pool = pool

    @property
    def handle(self):
        '''
        Retrieves the currently held thread handle, if any.

        NOT Thread-safe.
        '''
        return self._handle

    @handle.setter
    def handle(self, handle):
        '''
        Sets the thread handle for the worker.

        NOT Thread-safe.
        '''
        if handle is None:
            # clear state
            self._handle = None
            return

        if handle is not None and not isinstance(handle, threading.Thread):
            raise TypeError(
                'thread handle must be a threading.Thread: %r' % (handle)
            )

        with self._lock:
            self._handle = handle

    @property
    def name(self):
        '''
        Retrieves the name from the thread handle, if available.

        Thread-safe.
        '''
        with self._lock:
            if self._handle:
                return self._handle.name

        return None

    @name.setter
    def name(self, name):
        '''
        Sets the name of the held thread handle.

        Thread-safe.
        '''
        with self._lock:
            if self._handle:
                self._handle.name = name
            # else, meh, whatever

        return None

    def __repr__(self):
        return '%s(%r)' % ('Worker', {
            'pool': self.pool,
            'name': self.name,
            'handle': self.handle,
        })


class WorkerEvent(object):
    '''
    Helper class for managing worker events.

    A worker will generally care about two events:
        1.  A task is available in the task pool.
        2.  A stop has been requested for the worker.

    In either of these two cases, the worker should wake up, inspect the event,
    and then handle it appropriately.

    This is meant for use with `threading.Condition.wait_for`. Return one of
    these `WorkerEvent` instances in the predicate for the `Worker` to fetch.
    '''

    UNKNOWN = 'WorkerEvent.UNKNOWN'
    TASK = 'WorkerEvent.TASK'
    RUNSTATE = 'WorkerEvent.RUNSTATE'

    def __init__(self, event_type=None, data=None):
        self._event_type = None
        self._data = None

        if event_type is None:
            event_type = WorkerEvent.UNKNOWN
        self.event_type = event_type
        self.data = data

    @property
    def event_type(self):
        return self._event_type

    @event_type.setter
    def event_type(self, event_type):
        if not isinstance(event_type, int):
            raise TypeError('event type must be an int: %r' % (event_type))

        is_recognized = (
            event_type == WorkerEvent.UNKNOWN or
            event_type == WorkerEvent.TASK or
            event_type == WorkerEvent.RUNSTATE
        )
        if not is_recognized:
            logger.error('invalid worker event type: %r', event_type)
            raise ValueError('invalid worker event type: %r' % (event_type))

        self._event_type = event_type

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, data):
        # no validation, doesn't matter what it is
        self._data = data

    def is_task(self):
        return self.event_type == WorkerEvent.TASK

    def is_run_state(self):
        return self.event_type == WorkerEvent.RUNSTATE

    def __bool__(self):
        '''
        Boolean operator overload.

        This is meant to tell `threading.Condition.wait_for` that the event is
        of the desired type, and that it should wake the thread with it.
        '''
        return self.is_task() or self.is_run_state()

    def __str__(self):
        if self.is_task():
            return 'task-ready event'

        if self.is_run_state():
            return 'run-state-change event'

        return 'unknown event'

    def __repr__(self):
        return '%s(%r)' % ('WorkerEvent', {
            'event_type': self._event_type,
            'data': self._data,
        })
