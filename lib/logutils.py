#!/usr/bin/env python3

'''
lib/logutils.py
Contains additional logic to help improve logging output.
'''

import functools
import logging
import os
import re


# XXX : ST provides module sources from 'python3.3.zip'
#  e.g.     '/opt/st/python3.3.zip/logging/__init.pyo'
#       However while running, `sys._getframe` inspects the actual source file:
#           './python3.3/logging/__init__.py'
#       Fix it up!
try:
    import sublime          # noqa
    import sublime_plugin   # noqa

    # TODO : See if the one-liner solution here works:
    # logging._srcfile = os.path.normcase(addLevelName.__code__.co_filename)

    if hasattr(logging, '_srcfile') and logging._srcfile:
        python_zip_re = \
            re.compile(
                r'(?P<version>python(\w+)?(\.\w+)*)\.zip'
                r'(?P<path>[/\\].*$)'
            )
        python_zip_match = python_zip_re.search(logging._srcfile)
        if python_zip_match:
            python_version = python_zip_match.group('version')
            python_relative_file_path = python_zip_match.group('path')

            # fix it fix it fix it
            if os.sep == '\\':
                python_relative_posix_path = \
                    python_relative_file_path.replace(os.sep, '/')
            else:
                python_relative_posix_path = python_relative_file_path[:]

            srcfile_relative_posix_path = \
                re.sub(r'\.py[oc]$', '.py', python_relative_posix_path)

            srcfile_posix_path = './%s%s' % (
                python_version, srcfile_relative_posix_path,
            )

            srcfile_normalized_path = os.path.normcase(srcfile_posix_path)

            # if this doesn't calculate the right value, uncomment to debug:
            # print(
            #     'fixing logging srcfile: %s -> %s' %
            #     (logging._srcfile, srcfile_normalized_path)
            # )

            logging._srcfile = srcfile_normalized_path
except ImportError:
    # all good... phew
    pass

logger = logging.getLogger('sublime-ycmd.' + __name__)

LEVELNAME_MAXLEN = 1
FILENAME_MAXLEN = 12
LINENO_MAXLEN = 4
FUNCNAME_MAXLEN = 16


def get_default_datefmt():
    '''
    Returns a datetime format string for use in logging configuration.
    '''
    return '%Y/%m/%d %H:%M:%S'


def get_default_messagefmt():
    '''
    Returns a record format string for use in logging configuration.
    '''
    return \
        '[%%(asctime)s] %%(levelname)%ds %%(filename)%ds:%%(lineno)-%dd ' \
        '%%(funcName)-%ds %%(message)s' % \
        (LEVELNAME_MAXLEN, FILENAME_MAXLEN, LINENO_MAXLEN, FUNCNAME_MAXLEN)


def get_extended_messagefmt():
    '''
    Returns a record format string for use in logging configuration. This
    version includes some non-standard record items that are meant to be
    generated by log filters in this module. Remember to add these filters to
    the logger so that the extra record items are calculated.
    '''
    return \
        '[%%(asctime)s] %%(xlevelname)%ds %%(xfilename)%ds:%%(lineno)-%dd ' \
        '%%(xfuncname)-%ss %%(message)s' % \
        (LEVELNAME_MAXLEN, FILENAME_MAXLEN, LINENO_MAXLEN, FUNCNAME_MAXLEN)


def register_extension_filters(loginstance=None):
    '''
    Registers the filters that generated extended record entries. This includes
    all entries used in get_extended_messagefmt.
    If no instance is provided, this targets the root logger instance.
    '''
    if loginstance is None:
        root_logger = logging.getLogger()

        if not root_logger.hasHandlers():
            raise Exception('Root logger has no handlers, cannot bind to it')

        loginstance = root_logger.handlers[0]

    assert isinstance(loginstance, (logging.Logger, logging.Handler)), \
        'loginstance must be a Logger or Handler: %r' % loginstance

    xlevelname_filter = SYlogPropertyShortener().set_length(LEVELNAME_MAXLEN) \
        .set_property('levelname').set_result('xlevelname')
    xfilename_filter = SYlogPropertyShortener().set_length(FILENAME_MAXLEN) \
        .set_property('filename').set_result('xfilename')
    xfuncname_filter = SYlogPropertyShortener().set_length(FUNCNAME_MAXLEN) \
        .set_property('funcName').set_result('xfuncname')

    loginstance.addFilter(xlevelname_filter)
    loginstance.addFilter(xfilename_filter)
    loginstance.addFilter(xfuncname_filter)


# Used to strip common prefixes from script paths (namely, absolute paths)
_SY_LIB_DIR = os.path.dirname(os.path.abspath(__file__))


@functools.lru_cache()
def strip_common_path_prefix(basepath, relativeto=_SY_LIB_DIR):
    '''
    Strips the common prefix in a file path relative to the supplied path.
    By default, this uses the directory of this script to compare against.
    '''
    assert isinstance(basepath, str), \
        'basepath must be a string: %r' % basepath
    # Unfortunately, os.path.commonpath is only available in python 3.5+
    # To be compatible with 3.3, need to use commonprefix and then process it
    common_path_chars = os.path.commonprefix([basepath, relativeto])
    common_path_components = os.path.split(common_path_chars)
    # Don't use the last part (basename) - it is most likely garbage
    common_path_prefix_str = common_path_components[0]
    assert isinstance(common_path_prefix_str, str), \
        '[internal] common_path_prefix_str is not a string: %r' % \
        common_path_prefix_str
    assert basepath.startswith(common_path_prefix_str), \
        '[internal] basepath does not begin with common path prefix, ' \
        'calculation is incorrect: %r' % common_path_prefix_str
    # Since we know it starts with the prefix, just use a slice to get the rest
    common_path_prefix_len = len(common_path_prefix_str)
    tmp_stripped_prefix_path = basepath[common_path_prefix_len:]
    cleaned_stripped_prefix_path = \
        tmp_stripped_prefix_path.strip(os.path.sep + os.path.altsep)
    return cleaned_stripped_prefix_path


@functools.lru_cache()
def truncate_word_soft(word):
    '''
    Applies light truncation to a name component. So far, this just removes
    vowels (except first char). The result is probably not truncated by much.
    '''
    assert isinstance(word, str), \
        '[internal] word is not a string: %r' % word
    if not word:
        return word

    vowel_removal_re = '[aeiouAEIOU]'

    truncated_word = word[0] + re.sub(vowel_removal_re, '', word[1:])

    return truncated_word


@functools.lru_cache()
def truncate_word_hard(word):
    '''
    Applies aggressive truncation to a name component. So far, this just
    returns the first character of the supplied word. The result is very short.
    '''
    assert isinstance(word, str), \
        '[internal] word is not a string: %r' % word
    if word:
        return word[0]
    return word


@functools.lru_cache()
def delimit_name_components(basestr):
    '''
    Splits a string into a list of identifiers and separators.
    The original string can be reconstructed by joining the returned list.
    '''
    assert isinstance(basestr, str), \
        '[internal] basestr is not a string: %r' % basestr
    word_boundary_split_re = '([^a-zA-Z0-9])'

    split_components = re.split(word_boundary_split_re, basestr)

    return split_components


def smart_truncate(basestr, maxlen):
    '''
    Truncates a string while trying to maintain human-readability. The logic is
    quite limited. It can only truncate a few characters intelligently. If that
    still isn't enough, certain parts will be arbitrarily removed...
    '''
    assert isinstance(basestr, str), \
        'basestr must be a string: %r' % basestr
    assert isinstance(maxlen, int) and maxlen > 0, \
        'invalid maximum length: %r' % maxlen

    # If it looks like a path, strip away the common prefix
    if os.path.sep in basestr or os.path.altsep in basestr:
        # Yes, looks like a path
        basestr = strip_common_path_prefix(basestr)

    if len(basestr) <= maxlen:
        return basestr

    name_components = delimit_name_components(basestr)

    # Algorithm notes:
    # Loop through the name components, first applying soft truncation from
    # start to end. If, at any point, the length condition is satisfied, return
    # the reconstructed list. If, at the end, the length condition is not
    # satisfied, start again, applying hard truncation. Finally, if that
    # doesn't work, start dropping components altogether
    current_components = name_components[:]

    def get_current_length():
        ''' Returns the sum of the length of each component. '''
        return sum(map(len, current_components))

    def get_reconstructed():
        ''' Returns the string reconstructed from joining the components. '''
        return ''.join(current_components)

    def apply_truncate_until_satisfied(truncatefn):
        '''
        Applies the specified truncation function to the current working
        components until the length requirement is satisfied. Returns True if
        successful, and False if it was not enough. Either way, the current
        component state is updated after the application.
        '''
        for i, component in enumerate(current_components):
            truncated_component = truncatefn(component)
            current_components[i] = truncated_component
            if get_current_length() <= maxlen:
                return True
        return False

    if apply_truncate_until_satisfied(truncate_word_soft):
        return get_reconstructed()

    assert get_current_length() > maxlen, \
        '[internal] soft-truncate loop did not terminate properly, ' \
        'length condition already satisfied, currently at: %r' % \
        get_current_length()

    if apply_truncate_until_satisfied(truncate_word_hard):
        return get_reconstructed()

    assert get_current_length() > maxlen, \
        '[internal] hard-truncate loop did not terminate properly, ' \
        'length condition already satisfied, currently at: %r' % \
        get_current_length()

    # Well.... no choice but to remove components
    while current_components:
        del current_components[0]
        if current_components:
            # Also remove the non-word component following it
            del current_components[0]
        if get_current_length() <= maxlen:
            return get_reconstructed()

    assert False, \
        '[internal] failed to truncate, even after removing all components...'
    return ''


class SYlogPropertyShortener(logging.Filter):
    '''
    Logging filter that shortens property values to a desired target length.
    To use this class, the source property and target length must be set. If
    they are not set, this filter does not modify the record in any way.
    '''

    def __init__(self):
        super(SYlogPropertyShortener, self).__init__()
        self._source_property = None
        self._target_length = None
        self._result_property = None

    def set_property(self, source_property):
        '''
        Sets the property that this filter targets. When filtering, this
        property is looked up in the log record and processed.
        '''
        assert source_property is None or isinstance(source_property, str), \
            'source_property must be a str: %r' % source_property
        self._source_property = source_property
        return self

    def set_length(self, target_length):
        '''
        Sets the target length for the shortened property. When filtering, the
        source property will be shortened to be this length (at most).
        '''
        assert target_length is None or isinstance(target_length, int), \
            'target_length must be an int: %r' % target_length
        if target_length <= 0:
            raise ValueError('Target length must be a positive integer')
        self._target_length = target_length
        return self

    def set_result(self, result_property):
        '''
        Sets the property to store the shortened result into. When filtering,
        the shortened property will be placed in the log record under this
        name. If not set, the filter will update the source property in-place.
        '''
        assert result_property is None or isinstance(result_property, str), \
            'result_property must be a str: %r' % result_property
        self._result_property = result_property
        return self

    def filter(self, record):
        '''
        Log filter callback.
        Called by the parent logger when a record is to be logged. Always
        returns True, to indicate that the filter does not reject the message.
        '''
        if self._source_property is None or self._target_length is None:
            # Not configured, can't do anything
            return True

        source_property = self._source_property
        target_length = self._target_length
        result_property = self._result_property \
            if self._result_property is not None else source_property

        assert isinstance(source_property, str), \
            '[internal] source_property is not a str: %r' % source_property
        assert isinstance(target_length, int) and target_length > 0, \
            '[internal] target_length is not an int: %r' % target_length
        assert isinstance(result_property, str), \
            '[internal] result_property is not a str: %r' % result_property

        # Always initialize the result property - this ensures that the record
        # can populate the message format even if there is a failure
        if not hasattr(record, result_property):
            setattr(record, result_property, '?')

        if not hasattr(record, source_property):
            # Property unavailable, can't do anything
            return True

        source_value = getattr(record, source_property)
        try:
            truncated_value = smart_truncate(source_value, target_length)
        except Exception:
            # Failed to truncate, can't do anything
            return True

        setattr(record, result_property, truncated_value)
        return True

    def __str__(self):
        source_property = self._source_property
        target_length = self._target_length
        result_property = self._result_property \
            if self._result_property is not None else source_property

        return 'shorten("%s", %d) -> "%s"' % (
            source_property, target_length, result_property
        )

    def __repr__(self):
        source_property = self._source_property
        target_length = self._target_length
        result_property = self._result_property \
            if self._result_property is not None else source_property

        return '<SYlogPropertyShortener source="%s" length=%d result="%s">' % (
            source_property, target_length, result_property,
        )


class SYaddPrefixLogAdapter(logging.LoggerAdapter):
    '''
    Trivial log adapter wrapper class. This class helps the built-in python
    logger with calculating the caller frame. It must exist in a separate
    module for the caller lookup logic to grab the correct frame. Otherwise,
    the log adapter will tend to grab the caller frame of the logging module
    itself, which is probably not the desired behaviour...
    '''

    def __init__(self, logger, extra=None):
        super(SYaddPrefixLogAdapter, self).__init__(logger, extra or {})

    def process(self, msg, kwargs):
        p = self.prefix()

        return '%s%s' % (p, msg), kwargs

    def prefix(self):
        '''
        Override method to generate the prefix for log messages. This method
        should return a string, which will appear as a prefix in front of any
        log messages passed to the underlying logger.
        The default implementation returns an empty string, which will end up
        returning the original message as-is.
        Methods have access to the logger and extra parameters as
        `self.logger`, and `self.extra`, respectively.
        '''
        return ''
